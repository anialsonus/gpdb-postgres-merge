CREATE SCHEMA orca_static_pruning;
SET search_path TO orca_static_pruning;
CREATE TABLE rp (a int, b int, c int) DISTRIBUTED BY (a) PARTITION BY RANGE (b);
CREATE TABLE rp0 PARTITION OF rp FOR VALUES FROM (MINVALUE) TO (10);
NOTICE:  table has parent, setting distribution columns to match parent table
CREATE TABLE rp1 PARTITION OF rp FOR VALUES FROM (10) TO (20);
NOTICE:  table has parent, setting distribution columns to match parent table
CREATE TABLE rp2 PARTITION OF rp FOR VALUES FROM (4200) TO (4203);
NOTICE:  table has parent, setting distribution columns to match parent table
INSERT INTO rp VALUES (0, 0, 0), (11, 11, 0), (4201, 4201, 0);
SELECT $query$
SELECT *
FROM rp
WHERE b < 4200
$query$ AS qry \gset
SET optimizer_trace_fallback TO on;
EXPLAIN (COSTS OFF, VERBOSE)
:qry ;
                       QUERY PLAN                       
--------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: a, b, c
   ->  Sequence
         Output: a, b, c
         ->  Result
         ->  Dynamic Seq Scan on orca_static_pruning.rp
               Output: a, b, c
               Number of partitions to scan: 2 
               Filter: (rp.b < 4200)
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: optimizer=on
(11 rows)

:qry ;
 a  | b  | c 
----+----+---
  0 |  0 | 0
 11 | 11 | 0
(2 rows)

RESET optimizer_trace_fallback;
CREATE TABLE lp (a int, b int) DISTRIBUTED BY (a) PARTITION BY LIST (b);
CREATE TABLE lp0 PARTITION OF lp FOR VALUES IN (0, 1);
NOTICE:  table has parent, setting distribution columns to match parent table
CREATE TABLE lp1 PARTITION OF lp FOR VALUES IN (10, 11);
NOTICE:  table has parent, setting distribution columns to match parent table
CREATE TABLE lp0 PARTITION OF lp FOR VALUES IN (42, 43);
NOTICE:  table has parent, setting distribution columns to match parent table
ERROR:  relation "lp0" already exists
INSERT INTO lp VALUES (0, 0), (10, 10), (42, 42);
ERROR:  no partition of relation "lp" found for row  (seg0 172.17.0.2:7002 pid=225015)
DETAIL:  Partition key of the failing row contains (b) = (42).
SET optimizer_trace_fallback TO on;
SELECT $query$
SELECT *
FROM lp
WHERE b > 42
$query$ AS qry \gset
EXPLAIN (COSTS OFF, VERBOSE)
:qry ;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  DXL-to-PlStmt Translation: ArrayComp not supported
WARNING:  relcache reference leak: relation "lp" not closed
             QUERY PLAN              
-------------------------------------
 Result
   Output: a, b
   One-Time Filter: false
 Optimizer: Postgres query optimizer
 Settings: optimizer=on
(5 rows)

:qry ;
INFO:  GPORCA failed to produce a plan, falling back to planner
DETAIL:  DXL-to-PlStmt Translation: ArrayComp not supported
WARNING:  relcache reference leak: relation "lp" not closed
 a | b 
---+---
(0 rows)

