SELECT name, setting FROM pg_settings WHERE name LIKE 'enable%';
         name         | setting 
----------------------+---------
 enable_bitmapscan    | on
 enable_groupagg      | on
 enable_hashagg       | on
 enable_hashjoin      | on
 enable_indexonlyscan | on
 enable_indexscan     | on
 enable_material      | on
 enable_mergejoin     | off
 enable_nestloop      | off
 enable_seqscan       | on
 enable_sort          | on
 enable_tidscan       | on
(12 rows)

CREATE TABLE foo2(fooid int, f2 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'fooid' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO foo2 VALUES(1, 11);
INSERT INTO foo2 VALUES(2, 22);
INSERT INTO foo2 VALUES(1, 111);
CREATE FUNCTION foot(int) returns setof foo2 as 'SELECT * FROM foo2 WHERE fooid = $1 ORDER BY f2;' LANGUAGE SQL;
-- function with ORDINALITY
select * from foot(1) with ordinality as z(a,b,ord);
 a |  b  | ord 
---+-----+-----
 1 |  11 |   1
 1 | 111 |   2
(2 rows)

select * from foot(1) with ordinality as z(a,b,ord) where b > 100;   -- ordinal 2, not 1
 a |  b  | ord 
---+-----+-----
 1 | 111 |   2
(1 row)

-- ordinality vs. column names and types
select a,b,ord from foot(1) with ordinality as z(a,b,ord);
 a |  b  | ord 
---+-----+-----
 1 |  11 |   1
 1 | 111 |   2
(2 rows)

select a,ord from unnest(array['a','b']) with ordinality as z(a,ord);
 a | ord 
---+-----
 a |   1
 b |   2
(2 rows)

select * from unnest(array['a','b']) with ordinality as z(a,ord);
 a | ord 
---+-----
 a |   1
 b |   2
(2 rows)

select a,ord from unnest(array[1.0::float8]) with ordinality as z(a,ord);
 a | ord 
---+-----
 1 |   1
(1 row)

select * from unnest(array[1.0::float8]) with ordinality as z(a,ord);
 a | ord 
---+-----
 1 |   1
(1 row)

select row_to_json(s.*) from generate_series(11,14) with ordinality s;
       row_to_json       
-------------------------
 {"s":11,"ordinality":1}
 {"s":12,"ordinality":2}
 {"s":13,"ordinality":3}
 {"s":14,"ordinality":4}
(4 rows)

-- ordinality vs. views
create temporary view vw_ord as select * from (values (1)) v(n) join foot(1) with ordinality as z(a,b,ord) on (n=ord);
select * from vw_ord;
 n | a | b  | ord 
---+---+----+-----
 1 | 1 | 11 |   1
(1 row)

select definition from pg_views where viewname='vw_ord';
                             definition                              
---------------------------------------------------------------------
  SELECT v.n,                                                       +
     z.a,                                                           +
     z.b,                                                           +
     z.ord                                                          +
    FROM (( VALUES (1)) v(n)                                        +
      JOIN foot(1) WITH ORDINALITY z(a, b, ord) ON ((v.n = z.ord)));
(1 row)

drop view vw_ord;
-- multiple functions
select * from rows from(foot(1),foot(2)) with ordinality as z(a,b,c,d,ord);
 a |  b  | c | d  | ord 
---+-----+---+----+-----
 1 |  11 | 2 | 22 |   1
 1 | 111 |   |    |   2
(2 rows)

create temporary view vw_ord as select * from (values (1)) v(n) join rows from(foot(1),foot(2)) with ordinality as z(a,b,c,d,ord) on (n=ord);
select * from vw_ord;
 n | a | b  | c | d  | ord 
---+---+----+---+----+-----
 1 | 1 | 11 | 2 | 22 |   1
(1 row)

select definition from pg_views where viewname='vw_ord';
                                          definition                                           
-----------------------------------------------------------------------------------------------
  SELECT v.n,                                                                                 +
     z.a,                                                                                     +
     z.b,                                                                                     +
     z.c,                                                                                     +
     z.d,                                                                                     +
     z.ord                                                                                    +
    FROM (( VALUES (1)) v(n)                                                                  +
      JOIN ROWS FROM(foot(1), foot(2)) WITH ORDINALITY z(a, b, c, d, ord) ON ((v.n = z.ord)));
(1 row)

drop view vw_ord;
-- expansions of unnest()
select * from unnest(array[10,20],array['foo','bar'],array[1.0]);
 unnest | unnest | unnest 
--------+--------+--------
     10 | foo    |    1.0
     20 | bar    |       
(2 rows)

select * from unnest(array[10,20],array['foo','bar'],array[1.0]) with ordinality as z(a,b,c,ord);
 a  |  b  |  c  | ord 
----+-----+-----+-----
 10 | foo | 1.0 |   1
 20 | bar |     |   2
(2 rows)

select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) with ordinality as z(a,b,c,ord);
 a  |  b  |  c  | ord 
----+-----+-----+-----
 10 | foo | 1.0 |   1
 20 | bar |     |   2
(2 rows)

select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(101,102)) with ordinality as z(a,b,c,ord);
 a  |  b  |  c  | ord 
----+-----+-----+-----
 10 | foo | 101 |   1
 20 | bar | 102 |   2
(2 rows)

create temporary view vw_ord as select * from unnest(array[10,20],array['foo','bar'],array[1.0]) as z(a,b,c);
select * from vw_ord;
 a  |  b  |  c  
----+-----+-----
 10 | foo | 1.0
 20 | bar |    
(2 rows)

select definition from pg_views where viewname='vw_ord';
                                       definition                                       
----------------------------------------------------------------------------------------
  SELECT z.a,                                                                          +
     z.b,                                                                              +
     z.c                                                                               +
    FROM UNNEST(ARRAY[10, 20], ARRAY['foo'::text, 'bar'::text], ARRAY[1.0]) z(a, b, c);
(1 row)

drop view vw_ord;
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar'],array[1.0])) as z(a,b,c);
select * from vw_ord;
 a  |  b  |  c  
----+-----+-----
 10 | foo | 1.0
 20 | bar |    
(2 rows)

select definition from pg_views where viewname='vw_ord';
                                       definition                                       
----------------------------------------------------------------------------------------
  SELECT z.a,                                                                          +
     z.b,                                                                              +
     z.c                                                                               +
    FROM UNNEST(ARRAY[10, 20], ARRAY['foo'::text, 'bar'::text], ARRAY[1.0]) z(a, b, c);
(1 row)

drop view vw_ord;
create temporary view vw_ord as select * from rows from(unnest(array[10,20],array['foo','bar']), generate_series(1,2)) as z(a,b,c);
select * from vw_ord;
 a  |  b  | c 
----+-----+---
 10 | foo | 1
 20 | bar | 2
(2 rows)

select definition from pg_views where viewname='vw_ord';
                                                      definition                                                      
----------------------------------------------------------------------------------------------------------------------
  SELECT z.a,                                                                                                        +
     z.b,                                                                                                            +
     z.c                                                                                                             +
    FROM ROWS FROM(unnest(ARRAY[10, 20]), unnest(ARRAY['foo'::text, 'bar'::text]), generate_series(1, 2)) z(a, b, c);
(1 row)

drop view vw_ord;
-- ordinality and multiple functions vs. rewind and reverse scan
-- Backward scan not supported in GPDB, which makes this a lot less
-- interesting than in PostgreSQL.
begin;
declare foo scroll cursor for select * from rows from(generate_series(1,5),generate_series(1,2)) with ordinality as g(i,j,o);
fetch all from foo;
 i | j | o 
---+---+---
 1 | 1 | 1
 2 | 2 | 2
 3 |   | 3
 4 |   | 4
 5 |   | 5
(5 rows)

--fetch backward all from foo;
fetch all from foo;
 i | j | o 
---+---+---
(0 rows)

fetch next from foo;
 i | j | o 
---+---+---
(0 rows)

fetch next from foo;
 i | j | o 
---+---+---
(0 rows)

--fetch prior from foo;
--fetch absolute 1 from foo;
fetch next from foo;
 i | j | o 
---+---+---
(0 rows)

fetch next from foo;
 i | j | o 
---+---+---
(0 rows)

fetch next from foo;
 i | j | o 
---+---+---
(0 rows)

--fetch prior from foo;
--fetch prior from foo;
--fetch prior from foo;
commit;
-- function with implicit LATERAL
select * from foo2, foot(foo2.fooid) z where foo2.f2 = z.f2;
ERROR:  query plan with multiple segworker groups is not supported
HINT:  likely caused by a function that reads or modifies data in a distributed table
CONTEXT:  SQL function "foot" statement 1
-- function in subselect
select * from foo2 where f2 in (select f2 from foot(foo2.fooid) z where z.fooid = foo2.fooid) ORDER BY 1,2;
ERROR:  query plan with multiple segworker groups is not supported
HINT:  likely caused by a function that reads or modifies data in a distributed table
CONTEXT:  SQL function "foot" statement 1
-- function in subselect
select * from foo2 where f2 in (select f2 from foot(1) z where z.fooid = foo2.fooid) ORDER BY 1,2;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foo2"  (entry db 192.168.0.13:15432 pid=5692)
CONTEXT:  SQL function "foot" during startup
-- function in subselect
select * from foo2 where f2 in (select f2 from foot(foo2.fooid) z where z.fooid = 1) ORDER BY 1,2;
ERROR:  query plan with multiple segworker groups is not supported
HINT:  likely caused by a function that reads or modifies data in a distributed table
CONTEXT:  SQL function "foot" statement 1
-- nested functions
select foot.fooid, foot.f2 from foot(sin(pi()/2)::int) ORDER BY 1,2;
 fooid | f2  
-------+-----
     1 |  11
     1 | 111
(2 rows)

CREATE TABLE foo (fooid int, foosubid int, fooname text, primary key(fooid,foosubid));
INSERT INTO foo VALUES(1,1,'Joe');
INSERT INTO foo VALUES(1,2,'Ed');
INSERT INTO foo VALUES(2,1,'Mary');
-- sql, proretset = f, prorettype = b
CREATE FUNCTION getfoo(int) RETURNS int AS 'SELECT $1;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
 t1 
----
  1
(1 row)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 getfoo 
--------
      1
(1 row)

-- sql, proretset = t, prorettype = b
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS setof int AS 'SELECT fooid FROM foo WHERE fooid = $1;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
 t1 
----
  1
  1
(2 rows)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 getfoo 
--------
      1
      1
(2 rows)

-- sql, proretset = t, prorettype = b
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS setof text AS 'SELECT fooname FROM foo WHERE fooid = $1;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
 t1  
-----
 Joe
 Ed
(2 rows)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 getfoo 
--------
 Joe
 Ed
(2 rows)

-- sql, proretset = f, prorettype = c
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS foo AS 'SELECT * FROM foo WHERE fooid = $1 ORDER BY fooname DESC /* ORDER BY to force the Joe row to be returned */ ;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
(1 row)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
(1 row)

-- sql, proretset = t, prorettype = c
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS setof foo AS 'SELECT * FROM foo WHERE fooid = $1;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)

-- sql, proretset = f, prorettype = record
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS RECORD AS 'SELECT * FROM foo WHERE fooid = $1 ORDER BY fooname DESC /* ORDER BY to force the Joe row to be returned */ ;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1(fooid int, foosubid int, fooname text);
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
(1 row)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1) AS
(fooid int, foosubid int, fooname text);
SELECT * FROM vw_getfoo;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
(1 row)

-- sql, proretset = t, prorettype = record
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS setof record AS 'SELECT * FROM foo WHERE fooid = $1;' LANGUAGE SQL;
SELECT * FROM getfoo(1) AS t1(fooid int, foosubid int, fooname text);
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1) AS
(fooid int, foosubid int, fooname text);
SELECT * FROM vw_getfoo;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)

-- plpgsql, proretset = f, prorettype = b
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS int AS 'DECLARE fooint int; BEGIN SELECT fooid into fooint FROM foo WHERE fooid = $1; RETURN fooint; END;' LANGUAGE plpgsql;
SELECT * FROM getfoo(1) AS t1;
 t1 
----
  1
(1 row)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 getfoo 
--------
      1
(1 row)

-- plpgsql, proretset = f, prorettype = c
DROP VIEW vw_getfoo;
DROP FUNCTION getfoo(int);
CREATE FUNCTION getfoo(int) RETURNS foo AS 'DECLARE footup foo%ROWTYPE; BEGIN SELECT * into footup FROM foo WHERE fooid = $1 ORDER BY fooname DESC /* ORDER BY to force the Joe row to be returned */ ; RETURN footup; END;' LANGUAGE plpgsql;
SELECT * FROM getfoo(1) AS t1;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
(1 row)

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);
SELECT * FROM vw_getfoo;
 fooid | foosubid | fooname 
-------+----------+---------
     1 |        1 | Joe
(1 row)

DROP VIEW vw_getfoo;
CREATE VIEW vw_getfoo AS SELECT * FROM getfoo9(1) WITH ORDINALITY AS t1(a,b,c,o);
SELECT * FROM vw_getfoo;
 a | b |  c  | o 
---+---+-----+---
 1 | 1 | Joe | 1
(1 row)

DROP VIEW vw_getfoo;
-- mix 'n match kinds, to exercise expandRTE and related logic
select * from rows from(getfoo1(1),getfoo2(1),getfoo3(1),getfoo4(1),getfoo5(1),
                    getfoo6(1) AS (fooid int, foosubid int, fooname text),
                    getfoo7(1) AS (fooid int, foosubid int, fooname text),
                    getfoo8(1),getfoo9(1))
              with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
 a | b |  c  | d | e |  f  | g | h |  i  | j | k |  l  | m | o |  p  | q | r | s |  t  | u 
---+---+-----+---+---+-----+---+---+-----+---+---+-----+---+---+-----+---+---+---+-----+---
 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | 1 | Joe | 1
   | 1 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |   |     | 2
(2 rows)

select * from rows from(getfoo9(1),getfoo8(1),
                    getfoo7(1) AS (fooid int, foosubid int, fooname text),
                    getfoo6(1) AS (fooid int, foosubid int, fooname text),
                    getfoo5(1),getfoo4(1),getfoo3(1),getfoo2(1),getfoo1(1))
              with ordinality as t1(a,b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u);
 a | b |  c  | d | e | f |  g  | h | i |  j  | k | l |  m  | o | p |  q  |  r  | s | t | u 
---+---+-----+---+---+---+-----+---+---+-----+---+---+-----+---+---+-----+-----+---+---+---
 1 | 1 | Joe | 1 | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1 | Joe | Joe | 1 | 1 | 1
   |   |     |   | 1 | 2 | Ed  |   |   |     | 1 | 2 | Ed  |   |   |     | Ed  | 1 |   | 2
(2 rows)

create temporary view vw_foo as
  select * from rows from(getfoo9(1),
                      getfoo7(1) AS (fooid int, foosubid int, fooname text),
                      getfoo1(1))
                with ordinality as t1(a,b,c,d,e,f,g,n);
select * from vw_foo;
 a | b |  c  | d | e |  f  | g | n 
---+---+-----+---+---+-----+---+---
 1 | 1 | Joe | 1 | 1 | Joe | 1 | 1
   |   |     | 1 | 2 | Ed  |   | 2
(2 rows)

select pg_get_viewdef('vw_foo');
                                                                    pg_get_viewdef                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------
  SELECT t1.a,                                                                                                                                       +
     t1.b,                                                                                                                                           +
     t1.c,                                                                                                                                           +
     t1.d,                                                                                                                                           +
     t1.e,                                                                                                                                           +
     t1.f,                                                                                                                                           +
     t1.g,                                                                                                                                           +
     t1.n                                                                                                                                            +
    FROM ROWS FROM(getfoo9(1), getfoo7(1) AS (fooid integer, foosubid integer, fooname text), getfoo1(1)) WITH ORDINALITY t1(a, b, c, d, e, f, g, n);
(1 row)

drop view vw_foo;
DROP FUNCTION getfoo1(int);
DROP FUNCTION getfoo2(int);
DROP FUNCTION getfoo3(int);
DROP FUNCTION getfoo4(int);
DROP FUNCTION getfoo5(int);
DROP FUNCTION getfoo6(int);
DROP FUNCTION getfoo7(int);
DROP FUNCTION getfoo8(int);
DROP FUNCTION getfoo9(int);
DROP FUNCTION foot(int);
DROP TABLE foo2;
DROP TABLE foo;
-- Rescan tests --
CREATE TABLE foorescan (fooid int, foosubid int, fooname text, primary key(fooid,foosubid));
INSERT INTO foorescan values(5000,1,'abc.5000.1');
INSERT INTO foorescan values(5001,1,'abc.5001.1');
INSERT INTO foorescan values(5002,1,'abc.5002.1');
INSERT INTO foorescan values(5003,1,'abc.5003.1');
INSERT INTO foorescan values(5004,1,'abc.5004.1');
INSERT INTO foorescan values(5005,1,'abc.5005.1');
INSERT INTO foorescan values(5006,1,'abc.5006.1');
INSERT INTO foorescan values(5007,1,'abc.5007.1');
INSERT INTO foorescan values(5008,1,'abc.5008.1');
INSERT INTO foorescan values(5009,1,'abc.5009.1');
INSERT INTO foorescan values(5000,2,'abc.5000.2');
INSERT INTO foorescan values(5001,2,'abc.5001.2');
INSERT INTO foorescan values(5002,2,'abc.5002.2');
INSERT INTO foorescan values(5003,2,'abc.5003.2');
INSERT INTO foorescan values(5004,2,'abc.5004.2');
INSERT INTO foorescan values(5005,2,'abc.5005.2');
INSERT INTO foorescan values(5006,2,'abc.5006.2');
INSERT INTO foorescan values(5007,2,'abc.5007.2');
INSERT INTO foorescan values(5008,2,'abc.5008.2');
INSERT INTO foorescan values(5009,2,'abc.5009.2');
INSERT INTO foorescan values(5000,3,'abc.5000.3');
INSERT INTO foorescan values(5001,3,'abc.5001.3');
INSERT INTO foorescan values(5002,3,'abc.5002.3');
INSERT INTO foorescan values(5003,3,'abc.5003.3');
INSERT INTO foorescan values(5004,3,'abc.5004.3');
INSERT INTO foorescan values(5005,3,'abc.5005.3');
INSERT INTO foorescan values(5006,3,'abc.5006.3');
INSERT INTO foorescan values(5007,3,'abc.5007.3');
INSERT INTO foorescan values(5008,3,'abc.5008.3');
INSERT INTO foorescan values(5009,3,'abc.5009.3');
INSERT INTO foorescan values(5000,4,'abc.5000.4');
INSERT INTO foorescan values(5001,4,'abc.5001.4');
INSERT INTO foorescan values(5002,4,'abc.5002.4');
INSERT INTO foorescan values(5003,4,'abc.5003.4');
INSERT INTO foorescan values(5004,4,'abc.5004.4');
INSERT INTO foorescan values(5005,4,'abc.5005.4');
INSERT INTO foorescan values(5006,4,'abc.5006.4');
INSERT INTO foorescan values(5007,4,'abc.5007.4');
INSERT INTO foorescan values(5008,4,'abc.5008.4');
INSERT INTO foorescan values(5009,4,'abc.5009.4');
INSERT INTO foorescan values(5000,5,'abc.5000.5');
INSERT INTO foorescan values(5001,5,'abc.5001.5');
INSERT INTO foorescan values(5002,5,'abc.5002.5');
INSERT INTO foorescan values(5003,5,'abc.5003.5');
INSERT INTO foorescan values(5004,5,'abc.5004.5');
INSERT INTO foorescan values(5005,5,'abc.5005.5');
INSERT INTO foorescan values(5006,5,'abc.5006.5');
INSERT INTO foorescan values(5007,5,'abc.5007.5');
INSERT INTO foorescan values(5008,5,'abc.5008.5');
INSERT INTO foorescan values(5009,5,'abc.5009.5');
CREATE FUNCTION foorescan(int,int) RETURNS setof foorescan AS 'SELECT * FROM foorescan WHERE fooid >= $1 and fooid < $2 ;' LANGUAGE SQL;
--invokes ExecReScanFunctionScan
SELECT * FROM foorescan f WHERE f.fooid IN (SELECT fooid FROM foorescan(5002,5004)) ORDER BY 1,2;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foorescan"  (entry db 192.168.0.13:15432 pid=5692)
CONTEXT:  SQL function "foorescan" during startup
CREATE VIEW vw_foorescan AS SELECT * FROM foorescan(5002,5004);
--invokes ExecReScanFunctionScan
SELECT * FROM foorescan f WHERE f.fooid IN (SELECT fooid FROM vw_foorescan) ORDER BY 1,2;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foorescan"  (entry db 192.168.0.13:15432 pid=5692)
CONTEXT:  SQL function "foorescan" during startup
CREATE TABLE barrescan (fooid int primary key);
INSERT INTO barrescan values(5003);
INSERT INTO barrescan values(5004);
INSERT INTO barrescan values(5005);
INSERT INTO barrescan values(5006);
INSERT INTO barrescan values(5007);
INSERT INTO barrescan values(5008);
CREATE FUNCTION foorescan(int) RETURNS setof foorescan AS 'SELECT * FROM foorescan WHERE fooid = $1;' LANGUAGE SQL;
--invokes ExecReScanFunctionScan with chgParam != NULL
SELECT f.* FROM barrescan b, foorescan f WHERE f.fooid = b.fooid AND b.fooid IN (SELECT fooid FROM foorescan(b.fooid)) ORDER BY 1,2;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foorescan"  (entry db 127.0.0.1:15432 pid=2755)
CONTEXT:  SQL function "foorescan" during startup
SELECT b.fooid, max(f.foosubid) FROM barrescan b, foorescan f WHERE f.fooid = b.fooid AND b.fooid IN (SELECT fooid FROM foorescan(b.fooid)) GROUP BY b.fooid ORDER BY 1,2;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foorescan"  (entry db 127.0.0.1:15432 pid=2755)
CONTEXT:  SQL function "foorescan" during startup
CREATE VIEW fooview1 AS SELECT f.* FROM barrescan b, foorescan f WHERE f.fooid = b.fooid AND b.fooid IN (SELECT fooid FROM foorescan(b.fooid)) ORDER BY 1,2;
SELECT * FROM fooview1 AS fv WHERE fv.fooid = 5004;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foorescan"  (entry db 127.0.0.1:15432 pid=2755)
CONTEXT:  SQL function "foorescan" during startup
CREATE VIEW fooview2 AS SELECT b.fooid, max(f.foosubid) AS maxsubid FROM barrescan b, foorescan f WHERE f.fooid = b.fooid AND b.fooid IN (SELECT fooid FROM foorescan(b.fooid)) GROUP BY b.fooid ORDER BY 1,2;
SELECT * FROM fooview2 AS fv WHERE fv.maxsubid = 5;
ERROR:  function cannot execute on a QE slice because it accesses relation "public.foorescan"  (entry db 127.0.0.1:15432 pid=2755)
CONTEXT:  SQL function "foorescan" during startup
DROP VIEW vw_foorescan;
DROP VIEW fooview1;
DROP VIEW fooview2;
DROP FUNCTION foorescan(int,int);
DROP FUNCTION foorescan(int);
DROP TABLE foorescan;
DROP TABLE barrescan;
--
-- Test cases involving OUT parameters
--
CREATE FUNCTION foo(in f1 int, out f2 int)
AS 'select $1+1' LANGUAGE sql;
SELECT foo(42);
 foo 
-----
  43
(1 row)

SELECT * FROM foo(42);
 f2 
----
 43
(1 row)

SELECT * FROM foo(42) AS p(x);
 x  
----
 43
(1 row)

-- explicit spec of return type is OK
CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int) RETURNS int
AS 'select $1+1' LANGUAGE sql;
-- error, wrong result type
CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int) RETURNS float
AS 'select $1+1' LANGUAGE sql;
ERROR:  function result type must be integer because of OUT parameters
-- with multiple OUT params you must get a RECORD result
CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int, out f3 text) RETURNS int
AS 'select $1+1' LANGUAGE sql;
ERROR:  function result type must be record because of OUT parameters
CREATE OR REPLACE FUNCTION foo(in f1 int, out f2 int, out f3 text)
RETURNS record
AS 'select $1+1' LANGUAGE sql;
ERROR:  cannot change return type of existing function
HINT:  Use DROP FUNCTION foo(integer) first.
CREATE OR REPLACE FUNCTION foor(in f1 int, out f2 int, out text)
AS $$select $1-1, $1::text || 'z'$$ LANGUAGE sql;
SELECT f1, foor(f1) FROM int4_tbl;
     f1      |            foor            
-------------+----------------------------
           0 | (-1,0z)
      123456 | (123455,123456z)
     -123456 | (-123457,-123456z)
  2147483647 | (2147483646,2147483647z)
 -2147483647 | (-2147483648,-2147483647z)
(5 rows)

SELECT * FROM foor(42);
 f2 | column2 
----+---------
 41 | 42z
(1 row)

SELECT * FROM foor(42) AS p(a,b);
 a  |  b  
----+-----
 41 | 42z
(1 row)

CREATE OR REPLACE FUNCTION foob(in f1 int, inout f2 int, out text)
AS $$select $2-1, $1::text || 'z'$$ LANGUAGE sql;
SELECT f1, foob(f1, f1/2) FROM int4_tbl;
     f1      |            foob            
-------------+----------------------------
           0 | (-1,0z)
      123456 | (61727,123456z)
     -123456 | (-61729,-123456z)
  2147483647 | (1073741822,2147483647z)
 -2147483647 | (-1073741824,-2147483647z)
(5 rows)

SELECT * FROM foob(42, 99);
 f2 | column2 
----+---------
 98 | 42z
(1 row)

SELECT * FROM foob(42, 99) AS p(a,b);
 a  |  b  
----+-----
 98 | 42z
(1 row)

-- Can reference function with or without OUT params for DROP, etc
DROP FUNCTION foo(int);
DROP FUNCTION foor(in f2 int, out f1 int, out text);
DROP FUNCTION foob(in f1 int, inout f2 int);
--
-- For my next trick, polymorphic OUT parameters
--
CREATE FUNCTION dup (f1 anyelement, f2 out anyelement, f3 out anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
SELECT dup(22);
      dup       
----------------
 (22,"{22,22}")
(1 row)

SELECT dup('xyz');	-- fails
ERROR:  could not determine polymorphic type because input has type "unknown"
SELECT dup('xyz'::text);
        dup        
-------------------
 (xyz,"{xyz,xyz}")
(1 row)

SELECT * FROM dup('xyz'::text);
 f2  |    f3     
-----+-----------
 xyz | {xyz,xyz}
(1 row)

-- fails, as we are attempting to rename first argument
CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
ERROR:  cannot change name of input parameter "f1"
HINT:  Use DROP FUNCTION dup(anyelement) first.
DROP FUNCTION dup(anyelement);
-- equivalent behavior, though different name exposed for input arg
CREATE OR REPLACE FUNCTION dup (inout f2 anyelement, out f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
SELECT dup(22);
      dup       
----------------
 (22,"{22,22}")
(1 row)

DROP FUNCTION dup(anyelement);
-- fails, no way to deduce outputs
CREATE FUNCTION bad (f1 int, out f2 anyelement, out f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE sql;
ERROR:  cannot determine result data type
DETAIL:  A function returning a polymorphic type must have at least one polymorphic argument.
--
-- table functions
--
CREATE OR REPLACE FUNCTION foo()
RETURNS TABLE(a int)
AS $$ SELECT a FROM generate_series(1,5) a(a) $$ LANGUAGE sql;
SELECT * FROM foo();
 a 
---
 1
 2
 3
 4
 5
(5 rows)

DROP FUNCTION foo();
CREATE OR REPLACE FUNCTION foo(int)
RETURNS TABLE(a int, b int)
AS $$ SELECT a, b
         FROM generate_series(1,$1) a(a),
              generate_series(1,$1) b(b) $$ LANGUAGE sql;
SELECT * FROM foo(3);
 a | b 
---+---
 1 | 1
 1 | 2
 1 | 3
 2 | 1
 2 | 2
 2 | 3
 3 | 1
 3 | 2
 3 | 3
(9 rows)

DROP FUNCTION foo(int);
-- case that causes change of typmod knowledge during inlining
CREATE OR REPLACE FUNCTION foo()
RETURNS TABLE(a varchar(5))
AS $$ SELECT 'hello'::varchar(5) $$ LANGUAGE sql STABLE;
SELECT * FROM foo() GROUP BY 1;
   a   
-------
 hello
(1 row)

DROP FUNCTION foo();
--
-- some tests on SQL functions with RETURNING
--
create temp table tt(f1 serial, data text);
create function insert_tt(text) returns int as
$$ insert into tt(data) values($1) returning f1 $$
language sql;
select insert_tt('foo');
 insert_tt 
-----------
         1
(1 row)

select insert_tt('bar');
 insert_tt 
-----------
         2
(1 row)

select * from tt;
 f1 | data 
----+------
  1 | foo
  2 | bar
(2 rows)

-- insert will execute to completion even if function needs just 1 row
create or replace function insert_tt(text) returns int as
$$ insert into tt(data) values($1),($1||$1) returning (f1>0)::int $$
language sql;
select insert_tt('fool');
 insert_tt 
-----------
         1
(1 row)

select * from tt;
 f1 |   data   
----+----------
  1 | foo
  2 | bar
  3 | fool
  4 | foolfool
(4 rows)

-- setof does what's expected
create or replace function insert_tt2(text,text) returns setof int as
$$ insert into tt(data) values($1),($2) returning f1 $$
language sql;
select insert_tt2('foolish','barrish');
 insert_tt2 
------------
          5
          6
(2 rows)

select * from insert_tt2('baz','quux');
 insert_tt2 
------------
          7
          8
(2 rows)

select * from tt;
 f1 |   data   
----+----------
  1 | foo
  2 | bar
  3 | fool
  4 | foolfool
  5 | foolish
  6 | barrish
  7 | baz
  8 | quux
(8 rows)

-- limit doesn't prevent execution to completion
select insert_tt2('foolish','barrish') limit 1;
 insert_tt2 
------------
          9
(1 row)

select * from tt;
 f1 |   data   
----+----------
  1 | foo
  2 | bar
  3 | fool
  4 | foolfool
  5 | foolish
  6 | barrish
  7 | baz
  8 | quux
  9 | foolish
 10 | barrish
(10 rows)

-- add two dummy tuples to make the following
-- cases' insert tuples are (13,14) which
-- will be on the same seg under current
-- jump consistent hash. This will make the
-- case not flaky.
insert into tt(data) values ('nextisright');--11
insert into tt(data) values ('previswrong');--12
-- triggers will fire, too
create function noticetrigger() returns trigger as $$
begin
  raise notice 'noticetrigger % %', new.f1, new.data;
  return null;
end $$ language plpgsql;
create trigger tnoticetrigger after insert on tt for each row
execute procedure noticetrigger();
select insert_tt2('foolme','barme') limit 1;
NOTICE:  noticetrigger 13 foolme  (seg2 slice2 127.0.0.1:25434 pid=22720)
NOTICE:  noticetrigger 14 barme  (seg2 slice2 127.0.0.1:25434 pid=22720)
 insert_tt2 
------------
         13
(1 row)

select * from tt;
 f1 |    data     
----+-------------
  1 | foo
  3 | fool
 13 | foolme
 14 | barme
  4 | foolfool
  7 | baz
  8 | quux
 11 | nextisright
  2 | bar
  5 | foolish
  6 | barrish
  9 | foolish
 10 | barrish
 12 | previswrong
(14 rows)

-- add two dummy tuples to make the following
-- cases' insert tuples are (17,18) which
-- will be on the same seg under current
-- jump consistent hash. This will make the
-- case not flaky.
insert into tt(data) values ('nextiswrong');--15
NOTICE:  noticetrigger 15 nextiswrong  (seg2 127.0.0.1:25434 pid=22720)
insert into tt(data) values ('previsright');--16
NOTICE:  noticetrigger 16 previsright  (seg1 127.0.0.1:25433 pid=22719)
-- and rules work
create temp table tt_log(f1 int, data text);
create rule insert_tt_rule as on insert to tt do also
  insert into tt_log values(new.*);
select insert_tt2('foollog','barlog') limit 1;
NOTICE:  noticetrigger 17 foollog  (seg0 slice2 127.0.0.1:25432 pid=22718)
NOTICE:  noticetrigger 18 barlog  (seg0 slice2 127.0.0.1:25432 pid=22718)
 insert_tt2 
------------
         17
(1 row)

select * from tt;
 f1 |    data     
----+-------------
  2 | bar
  5 | foolish
  6 | barrish
  9 | foolish
 10 | barrish
 12 | previswrong
 16 | previsright
  1 | foo
  3 | fool
 13 | foolme
 14 | barme
 15 | nextiswrong
  4 | foolfool
  7 | baz
  8 | quux
 11 | nextisright
 17 | foollog
 18 | barlog
(18 rows)

-- note that nextval() gets executed a second time in the rule expansion,
-- which is expected.
select * from tt_log;
 f1 |  data   
----+---------
 19 | foollog
 20 | barlog
(2 rows)

-- test case for a whole-row-variable bug
create function foo1(n integer, out a text, out b text)
  returns setof record
  language sql
  as $$ select 'foo ' || i, 'bar ' || i from generate_series(1,$1) i $$;
set work_mem='64kB';
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
select t.a, t, t.a from foo1(10000) t limit 1;
   a   |         t         |   a   
-------+-------------------+-------
 foo 1 | ("foo 1","bar 1") | foo 1
(1 row)

reset work_mem;
WARNING:  "work_mem": setting is deprecated, and may be removed in a future release.
select t.a, t, t.a from foo1(10000) t limit 1;
   a   |         t         |   a   
-------+-------------------+-------
 foo 1 | ("foo 1","bar 1") | foo 1
(1 row)

drop function foo1(n integer);
-- test use of SQL functions returning record
-- this is supported in some cases where the query doesn't specify
-- the actual record type ...
create function array_to_set(anyarray) returns setof record as $$
  select i AS "index", $1[i] AS "value" from generate_subscripts($1, 1) i
$$ language sql strict immutable;
select array_to_set(array['one', 'two']);
 array_to_set 
--------------
 (1,one)
 (2,two)
(2 rows)

select * from array_to_set(array['one', 'two']) as t(f1 int,f2 text);
 f1 | f2  
----+-----
  1 | one
  2 | two
(2 rows)

select * from array_to_set(array['one', 'two']); -- fail
ERROR:  a column definition list is required for functions returning "record"
LINE 1: select * from array_to_set(array['one', 'two']);
                      ^
create temp table foo(f1 int8, f2 int8);
create function testfoo() returns record as $$
  insert into foo values (1,2) returning *;
$$ language sql;
select testfoo();
 testfoo 
---------
 (1,2)
(1 row)

select * from testfoo() as t(f1 int8,f2 int8);
 f1 | f2 
----+----
  1 |  2
(1 row)

select * from testfoo(); -- fail
ERROR:  a column definition list is required for functions returning "record"
LINE 1: select * from testfoo();
                      ^
drop function testfoo();
create function testfoo() returns setof record as $$
  insert into foo values (1,2), (3,4) returning *;
$$ language sql;
select testfoo();
 testfoo 
---------
 (1,2)
 (3,4)
(2 rows)

select * from testfoo() as t(f1 int8,f2 int8);
 f1 | f2 
----+----
  1 |  2
  3 |  4
(2 rows)

select * from testfoo(); -- fail
ERROR:  a column definition list is required for functions returning "record"
LINE 1: select * from testfoo();
                      ^
drop function testfoo();
--
-- Check some cases involving added/dropped columns in a rowtype result
--
create temp table users (userid text, seq int, email text, todrop bool, moredrop int, enabled bool);
insert into users values ('id',1,'email',true,11,true);
insert into users values ('id2',2,'email2',true,12,true);
alter table users drop column todrop;
create or replace function get_first_user() returns users as
$$ SELECT * FROM users ORDER BY userid LIMIT 1; $$
language sql stable;
SELECT get_first_user();
  get_first_user   
-------------------
 (id,1,email,11,t)
(1 row)

SELECT * FROM get_first_user();
 userid | seq | email | moredrop | enabled 
--------+-----+-------+----------+---------
 id     |   1 | email |       11 | t
(1 row)

create or replace function get_users() returns setof users as
$$ SELECT * FROM users ORDER BY userid; $$
language sql stable;
SELECT get_users();
      get_users      
---------------------
 (id,1,email,11,t)
 (id2,2,email2,12,t)
(2 rows)

SELECT * FROM get_users();
 userid | seq | email  | moredrop | enabled 
--------+-----+--------+----------+---------
 id     |   1 | email  |       11 | t
 id2    |   2 | email2 |       12 | t
(2 rows)

SELECT * FROM get_users() WITH ORDINALITY;   -- make sure ordinality copes
 userid | seq | email  | moredrop | enabled | ordinality 
--------+-----+--------+----------+---------+------------
 id     |   1 | email  |       11 | t       |          1
 id2    |   2 | email2 |       12 | t       |          2
(2 rows)

-- multiple functions vs. dropped columns
SELECT * FROM ROWS FROM(generate_series(10,11), get_users()) WITH ORDINALITY;
 generate_series | userid | seq | email  | moredrop | enabled | ordinality 
-----------------+--------+-----+--------+----------+---------+------------
              10 | id     |   1 | email  |       11 | t       |          1
              11 | id2    |   2 | email2 |       12 | t       |          2
(2 rows)

SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
 userid | seq | email  | moredrop | enabled | generate_series | ordinality 
--------+-----+--------+----------+---------+-----------------+------------
 id     |   1 | email  |       11 | t       |              10 |          1
 id2    |   2 | email2 |       12 | t       |              11 |          2
(2 rows)

-- check that we can cope with post-parsing changes in rowtypes
create temp view usersview as
SELECT * FROM ROWS FROM(get_users(), generate_series(10,11)) WITH ORDINALITY;
select * from usersview;
 userid | seq | email  | moredrop | enabled | generate_series | ordinality 
--------+-----+--------+----------+---------+-----------------+------------
 id     |   1 | email  |       11 | t       |              10 |          1
 id2    |   2 | email2 |       12 | t       |              11 |          2
(2 rows)

alter table users drop column moredrop;
select * from usersview;
 userid | seq | email  | moredrop | enabled | generate_series | ordinality 
--------+-----+--------+----------+---------+-----------------+------------
 id     |   1 | email  |          | t       |              10 |          1
 id2    |   2 | email2 |          | t       |              11 |          2
(2 rows)

alter table users add column junk text;
select * from usersview;
 userid | seq | email  | moredrop | enabled | generate_series | ordinality 
--------+-----+--------+----------+---------+-----------------+------------
 id     |   1 | email  |          | t       |              10 |          1
 id2    |   2 | email2 |          | t       |              11 |          2
(2 rows)

alter table users alter column seq type numeric;
select * from usersview;  -- expect clean failure
ERROR:  attribute 2 has wrong type
DETAIL:  Table has type numeric, but query expects integer.
drop view usersview;
drop function get_first_user();
drop function get_users();
drop table users;
-- this won't get inlined because of type coercion, but it shouldn't fail
create or replace function foobar() returns setof text as
$$ select 'foo'::varchar union all select 'bar'::varchar ; $$
language sql stable;
select foobar();
 foobar 
--------
 foo
 bar
(2 rows)

select * from foobar();
 foobar 
--------
 foo
 bar
(2 rows)

drop function foobar();
-- check handling of a SQL function with multiple OUT params (bug #5777)
create or replace function foobar(out integer, out numeric) as
$$ select (1, 2.1) $$ language sql;
select * from foobar();
 column1 | column2 
---------+---------
       1 |     2.1
(1 row)

create or replace function foobar(out integer, out numeric) as
$$ select (1, 2) $$ language sql;
select * from foobar();  -- fail
ERROR:  function return row and query-specified return row do not match
DETAIL:  Returned type integer at ordinal position 2, but query expects numeric.
create or replace function foobar(out integer, out numeric) as
$$ select (1, 2.1, 3) $$ language sql;
select * from foobar();  -- fail
ERROR:  function return row and query-specified return row do not match
DETAIL:  Returned row contains 3 attributes, but query expects 2.
drop function foobar();
-- check behavior when a function's input sometimes returns a set (bug #8228)
SELECT *,
  lower(CASE WHEN id = 2 THEN (regexp_matches(str, '^0*([1-9]\d+)$'))[1]
        ELSE str
        END)
FROM
  (VALUES (1,''), (2,'0000000049404'), (3,'FROM 10000000876')) v(id, str);
 id |       str        |      lower       
----+------------------+------------------
  1 |                  | 
  2 | 0000000049404    | 49404
  3 | FROM 10000000876 | from 10000000876
(3 rows)

