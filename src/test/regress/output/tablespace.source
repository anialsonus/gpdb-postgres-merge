-- start_matchignore
-- m/WARNING:  tablespace symlink path is too long for TAR/
-- m/DETAIL:  The symlinked path \".*\" will be truncated to 100 characters when sending a TAR to the utilities \(e.g. pg_basebackup\)/
-- end_matchignore
-- create a tablespace using WITH clause
CREATE TABLESPACE regress_tblspacewith LOCATION '@testtablespace@' WITH (some_nonexistent_parameter = true); -- fail
ERROR:  unrecognized parameter "some_nonexistent_parameter"
CREATE TABLESPACE regress_tblspacewith LOCATION '@testtablespace@' WITH (random_page_cost = 3.0); -- ok
-- check to see the parameter was used
SELECT spcoptions FROM pg_tablespace WHERE spcname = 'regress_tblspacewith';
       spcoptions       
------------------------
 {random_page_cost=3.0}
(1 row)

-- drop the tablespace so we can re-use the location
DROP TABLESPACE regress_tblspacewith;
-- create a tablespace we can use
<<<<<<< HEAD
CREATE TABLESPACE testspace LOCATION '@testtablespace@';
=======
CREATE TABLESPACE regress_tblspace LOCATION '@testtablespace@';
-- try setting and resetting some properties for the new tablespace
ALTER TABLESPACE regress_tblspace SET (random_page_cost = 1.0);
ALTER TABLESPACE regress_tblspace SET (some_nonexistent_parameter = true);  -- fail
ERROR:  unrecognized parameter "some_nonexistent_parameter"
ALTER TABLESPACE regress_tblspace RESET (random_page_cost = 2.0); -- fail
ERROR:  RESET must not include values for parameters
ALTER TABLESPACE regress_tblspace RESET (random_page_cost, seq_page_cost); -- ok
>>>>>>> b5bce6c1ec6061c8a4f730d927e162db7e2ce365
-- create a schema we can use
CREATE SCHEMA testschema;
-- try a table
CREATE TABLE testschema.foo (i int) TABLESPACE regress_tblspace;
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c
    where c.reltablespace = t.oid AND c.relname = 'foo';
 relname |     spcname      
---------+------------------
 foo     | regress_tblspace
(1 row)

INSERT INTO testschema.foo VALUES(1);
INSERT INTO testschema.foo VALUES(2);
-- tables from dynamic sources
CREATE TABLE testschema.asselect TABLESPACE regress_tblspace AS SELECT 1;
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c
    where c.reltablespace = t.oid AND c.relname = 'asselect';
 relname  |     spcname      
----------+------------------
 asselect | regress_tblspace
(1 row)

PREPARE selectsource(int) AS SELECT $1;
CREATE TABLE testschema.asexecute TABLESPACE regress_tblspace
    AS EXECUTE selectsource(2);
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c
    where c.reltablespace = t.oid AND c.relname = 'asexecute';
  relname  |     spcname      
-----------+------------------
 asexecute | regress_tblspace
(1 row)

-- index
CREATE INDEX foo_idx on testschema.foo(i) TABLESPACE regress_tblspace;
SELECT relname, spcname FROM pg_catalog.pg_tablespace t, pg_catalog.pg_class c
    where c.reltablespace = t.oid AND c.relname = 'foo_idx';
 relname |     spcname      
---------+------------------
 foo_idx | regress_tblspace
(1 row)

-- check that default_tablespace doesn't affect ALTER TABLE index rebuilds
CREATE TABLE testschema.test_default_tab(id bigint) TABLESPACE testspace;
INSERT INTO testschema.test_default_tab VALUES (1);
CREATE INDEX test_index1 on testschema.test_default_tab (id);
CREATE INDEX test_index2 on testschema.test_default_tab (id) TABLESPACE testspace;
\d testschema.test_index1
Index "testschema.test_index1"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"

\d testschema.test_index2
Index "testschema.test_index2"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"
Tablespace: "testspace"

-- use a custom tablespace for default_tablespace
SET default_tablespace TO testspace;
-- tablespace should not change if no rewrite
ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
ERROR:  cannot alter indexed column
HINT:  DROP the index first, and recreate it after the ALTER
\d testschema.test_index1
Index "testschema.test_index1"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"

\d testschema.test_index2
Index "testschema.test_index2"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"
Tablespace: "testspace"

ANALYZE testschema.test_default_tab;
SELECT * FROM testschema.test_default_tab;
 id 
----
  1
(1 row)

-- tablespace should not change even if there is an index rewrite
ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
ERROR:  cannot alter indexed column
HINT:  DROP the index first, and recreate it after the ALTER
\d testschema.test_index1
Index "testschema.test_index1"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"

\d testschema.test_index2
Index "testschema.test_index2"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"
Tablespace: "testspace"

ANALYZE testschema.test_default_tab;
SELECT * FROM testschema.test_default_tab;
 id 
----
  1
(1 row)

-- now use the default tablespace for default_tablespace
SET default_tablespace TO '';
-- tablespace should not change if no rewrite
ALTER TABLE testschema.test_default_tab ALTER id TYPE int;
ERROR:  cannot alter indexed column
HINT:  DROP the index first, and recreate it after the ALTER
\d testschema.test_index1
Index "testschema.test_index1"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"

\d testschema.test_index2
Index "testschema.test_index2"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"
Tablespace: "testspace"

-- tablespace should not change even if there is an index rewrite
ALTER TABLE testschema.test_default_tab ALTER id TYPE bigint;
ERROR:  cannot alter indexed column
HINT:  DROP the index first, and recreate it after the ALTER
\d testschema.test_index1
Index "testschema.test_index1"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"

\d testschema.test_index2
Index "testschema.test_index2"
 Column |  Type  | Definition 
--------+--------+------------
 id     | bigint | id
btree, for table "testschema.test_default_tab"
Tablespace: "testspace"

DROP TABLE testschema.test_default_tab;
-- let's try moving a table from one place to another
CREATE TABLE testschema.atable AS VALUES (1), (2);
alter table testschema.atable set with (reorganize=true) distributed by (column1);
CREATE UNIQUE INDEX anindex ON testschema.atable(column1);
ALTER TABLE testschema.atable SET TABLESPACE regress_tblspace;
ALTER INDEX testschema.anindex SET TABLESPACE regress_tblspace;
INSERT INTO testschema.atable VALUES(3);	-- ok
INSERT INTO testschema.atable VALUES(1);	-- fail (checks index)
ERROR:  duplicate key value violates unique constraint "anindex"
DETAIL:  Key (column1)=(1) already exists.
SELECT COUNT(*) FROM testschema.atable;		-- checks heap
 count 
-------
     3
(1 row)

-- Will fail with bad path
CREATE TABLESPACE regress_badspace LOCATION '/no/such/location';
ERROR:  directory "/no/such/location" does not exist
-- No such tablespace
CREATE TABLE bar (i int) TABLESPACE regress_nosuchspace;
ERROR:  tablespace "regress_nosuchspace" does not exist
-- Fail, not empty
<<<<<<< HEAD
DROP TABLESPACE testspace;
ERROR:  tablespace "testspace" is not empty
CREATE ROLE tablespace_testuser1 login;
CREATE ROLE tablespace_testuser2 login;
GRANT USAGE ON SCHEMA testschema TO tablespace_testuser2;
ALTER TABLESPACE testspace OWNER TO tablespace_testuser1;
CREATE TABLE testschema.tablespace_acl (c int);
-- new owner lacks permission to create this index from scratch
CREATE INDEX k ON testschema.tablespace_acl (c) TABLESPACE testspace;
ALTER TABLE testschema.tablespace_acl OWNER TO tablespace_testuser2;
SET SESSION ROLE tablespace_testuser2;
CREATE TABLE tablespace_table (i int) TABLESPACE testspace; -- fail
ERROR:  permission denied for tablespace testspace
ALTER TABLE testschema.tablespace_acl ALTER c TYPE bigint;
ERROR:  cannot alter indexed column
HINT:  DROP the index first, and recreate it after the ALTER
RESET ROLE;
ALTER TABLESPACE testspace RENAME TO testspace_renamed;
-- Test that default_tablespace GUC is honored even after gang reset.
CREATE OR REPLACE FUNCTION cleanupAllGangs() RETURNS BOOL
AS '@abs_builddir@/regress@DLSUFFIX@', 'cleanupAllGangs' LANGUAGE C;
SET default_tablespace TO testspace_renamed;
-- Destroy the QD-QE libpq connections.
select cleanupAllGangs();
 cleanupallgangs 
-----------------
 t
(1 row)

-- New gang will be setup to dispatch this DDL and default_tablespace
-- should be set to testspace_renamed on QEs.
CREATE TABLE tablespace_table1(a int, b int) DISTRIBUTED BY (a);
SELECT spcname FROM pg_class c, pg_tablespace t
WHERE c.reltablespace = t.oid and c.relname = 'tablespace_table1';
      spcname      
-------------------
 testspace_renamed
(1 row)

SELECT spcname FROM gp_dist_random('pg_class') c, pg_tablespace t
WHERE c.reltablespace = t.oid and c.relname = 'tablespace_table1';
      spcname      
-------------------
 testspace_renamed
 testspace_renamed
 testspace_renamed
(3 rows)

ALTER TABLE ALL IN TABLESPACE testspace_renamed SET TABLESPACE pg_default;
ALTER INDEX ALL IN TABLESPACE testspace_renamed SET TABLESPACE pg_default;
=======
DROP TABLESPACE regress_tblspace;
ERROR:  tablespace "regress_tblspace" is not empty
CREATE ROLE regress_tablespace_user1 login;
CREATE ROLE regress_tablespace_user2 login;
ALTER TABLESPACE regress_tblspace OWNER TO regress_tablespace_user1;
SET SESSION ROLE regress_tablespace_user2;
CREATE TABLE tablespace_table (i int) TABLESPACE regress_tblspace; -- fail
ERROR:  permission denied for tablespace regress_tblspace
RESET ROLE;
ALTER TABLESPACE regress_tblspace RENAME TO regress_tblspace_renamed;
ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
ALTER INDEX ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
>>>>>>> b5bce6c1ec6061c8a4f730d927e162db7e2ce365
-- Should show notice that nothing was done
ALTER TABLE ALL IN TABLESPACE regress_tblspace_renamed SET TABLESPACE pg_default;
NOTICE:  no matching relations in tablespace "regress_tblspace_renamed" found
-- Should succeed
DROP TABLESPACE regress_tblspace_renamed;
DROP SCHEMA testschema CASCADE;
NOTICE:  drop cascades to 5 other objects
DETAIL:  drop cascades to table testschema.foo
drop cascades to table testschema.asselect
drop cascades to table testschema.asexecute
drop cascades to table testschema.atable
<<<<<<< HEAD
drop cascades to table testschema.tablespace_acl
DROP ROLE tablespace_testuser1;
DROP ROLE tablespace_testuser2;
=======
DROP ROLE regress_tablespace_user1;
DROP ROLE regress_tablespace_user2;
>>>>>>> b5bce6c1ec6061c8a4f730d927e162db7e2ce365
